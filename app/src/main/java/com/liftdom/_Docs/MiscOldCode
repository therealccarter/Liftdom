


w531fb
public boolean isIncreaseDate(){
    boolean increase = false;



    return increase;
}

//int weekType;
//
        //if(week % 3 == 0){
        //    weekType = 3;
        //}else if(week % 2 == 0){
        //    weekType = 2;
        //}else{
        //    weekType = 1;
        //}
public class StatChartsFrag2 extends Fragment {

    public StatChartsFrag2() {
        // Required empty public constructor
    }

    @BindView(R.id.lineChart) LineChart lineChart;
    @BindView(R.id.graphingSelectorButton) Button graphingSelector;
    @BindView(R.id.overallRadioButton) RadioButton overallRadioButton;
    @BindView(R.id.maxWeightRadioButton) RadioButton maxWeightRadioButton;
    @BindView(R.id.itemsBeingGraphed) TextView itemsTextView;
    @BindView(R.id.reloadChartButton) Button reloadChart;
    @BindView(R.id.clearChartButton) Button clearChart;
    @BindView(R.id.titleView) TextView titleView;

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        // Inflate the layout for this fragment
        View view = inflater.inflate(R.layout.fragment_stat_charts, container, false);

        ButterKnife.bind(this, view);

        return view;
    }

    public void valueConverter(final ArrayList<ValueAndDateObject> valueAndDateArrayList, String exName, boolean
            isOverall){

    }
}

WorkoutHistoryModelClass historyModelClass = new WorkoutHistoryModelClass(userModelClass.getUserId(),
                            userModelClass.getUserName(), publicDescription, privateJournal, date, mediaRef,
                            workoutInfoMapProcessed, isImperial);

                    //if (!isFirstTimeFirstTime) {//
                        workoutHistoryRef.setValue(historyModelClass).addOnCompleteListener(new OnCompleteListener<Void>() {
                            @Override
                            public void onComplete(@NonNull Task<Void> task) {
                                ActivityManager manager = (ActivityManager) getActivity().getSystemService(Context.ACTIVITY_SERVICE);
                                if (manager.getRunningServices(Integer.MAX_VALUE) != null) {
                                    for (ActivityManager.RunningServiceInfo serviceInfo : manager.getRunningServices(Integer.MAX_VALUE)) {
                                        if (AssistorServiceClass.class.getName().equals(serviceInfo.service
                                                .getClassName())) {
                                            Intent stopIntent = new Intent(getActivity(), AssistorServiceClass.class);
                                            getActivity().stopService(stopIntent);
                                        }
                                    }
                                }
                                DatabaseReference runningRef = FirebaseDatabase.getInstance().getReference().child
                                        ("runningAssistor").child(uid).child("assistorModel");

                                runningRef.addListenerForSingleValueEvent(new
                                ValueEventListener() {
                                    @Override
                                    public void onDataChange(@NonNull DataSnapshot dataSnapshot) {
                                        WorkoutProgressModelClass workoutProgressModelClass =
                                                dataSnapshot.getValue(WorkoutProgressModelClass
                                                        .class);
                                        workoutProgressModelClass.setRefKey(REFKEY);
                                        workoutProgressModelClass.setIsRevise(false);
                                        workoutProgressModelClass.setCompletedBool(true);
                                        workoutProgressModelClass.setExInfoHashMap(completedMap);
//
                                        runningRef.setValue(workoutProgressModelClass);
                                    }
                                    //
                                    @Override
                                    public void onCancelled(@NonNull DatabaseError
                                                                    databaseError) {
//
                                    }
                                });

                                //Handler handler = new Handler();
                                //handler.postDelayed(new Runnable() {
                                //    @Override
                                //    public void run() {
                                //
                                //    }
                                //}, 15000);



                                //Map runningMa = new HashMap<>();
//
                                //runningMa.put("/refKey", REFKEY);
                                //runningMa.put("/isRevise", false);
                                //runningMa.put("/completedBool", true);
//
                                //runningRef.updateChildren(runningMa);
                            }
                        });
TE running problem, it was imperial, then set profile to kgs. In TE running, the units changed to
kgs, but when i entered 10 (kgs), saved, then came back, it was 22 kgs. So if the TE knows it's
imperial first, it's directly saving what's in the edit text and thinking that's still imperial.
Then taking that number thinking it's imperial and then seeing that we're now kgs, it's trying to
convert it back. This might be problem in normal TE? and WA.
What should happen?
    - If you're editing something as that POV, shouldn't we assume that the template becomes that as
     well?
    - Therefore, if a Template was imperial, but you are now editing it in kgs, it should become kgs.
    - The only place it should "convert" the value from whatever the Template was to what the POV
    is, is when it first reads it in.
    - We can solve this by simply making the update set the template units to the POV.
    - ok it updated to the right units, but it didn't save the new weight. it was 10(kgs), switched
    to imperial, it switched to 22lbs, but when we updated it kept the 10 and not the 22...

    - so the true problem here is that when updating, it tries to convert the weight before updating
     instead of just updating the weight.
    - fixed in TE, now gotta investigate behavior in WA.
        - ok and when it converts from imperial to metric, it should be the closest decimal with .5
        or a flat number. ie ties into the decimal feature.
    - noprogress should detect and convert from template units. then we set a running units, and if
    it's from the running node we detect and convert from that.

package com.liftdom.workout_assistor;
import android.graphics.Color;
import android.os.Bundle;
import androidx.fragment.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.TextView;
import butterknife.BindView;
import butterknife.ButterKnife;
import com.liftdom.liftdom.R;

/**
 * A simple {@link Fragment} subclass.
 */
public class RepsWeightFrag extends Fragment {


    public RepsWeightFrag() {
        // Required empty public constructor
    }

    int setNumber;


    public String reps = "fail";
    public String weight = "fail";
    public String parentExercise = "failed";
    public String fullString = "failed";
    public boolean isFromCalendar = false;
    public boolean isCheckbox = false;

    @BindView(R.id.repsEditText) EditText repsEditText;
    @BindView(R.id.weightEditText) EditText weightEditText;
    @BindView(R.id.checkBox) CheckBox checkBox;
    @BindView(R.id.main_layout) LinearLayout mainLayout;
    @BindView(R.id.pounds) TextView pounds;

    Bundle mSaved;

    View view;

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        // Inflate the layout for this fragment
        view = inflater.inflate(R.layout.fragment_reps_weight, container, false);

        ButterKnife.bind(this, view);

        mSaved = savedInstanceState;

        repsEditText.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                if(repsEditText.getText().toString().equals("0")){
                    repsEditText.setText("");
                }
            }
        });

        weightEditText.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                if(weightEditText.getText().toString().equals("0")){
                    weightEditText.setText("");
                }
            }
        });

        repsEditText.setText(reps);
        if(weight.equals("B.W.")){
            weightEditText.setText(weight);
            weightEditText.setEnabled(false);
            pounds.setVisibility(View.GONE);
            weightEditText.setTextColor(Color.parseColor("#000000"));
        }else{
            weightEditText.setText(weight);
        }

        if(isFromCalendar){
            checkBox.setVisibility(View.GONE);
        }

        checkBox.setOnClickListener(new View.OnClickListener() {
            public void onClick(View v) {
                if(checkBox.isChecked()){
                    mainLayout.setBackgroundColor(Color.parseColor("#EBEBEB"));
                } else{
                    mainLayout.setBackgroundColor(Color.parseColor("#FFFFFF"));
                }
            }
        });

        if(isCheckbox){
            checkBox.setChecked(true);
        }

        return view;
    }

    @Override
    public void onPause(){
        super.onPause();

        if(mSaved == null && !isFromCalendar) {
            CheckBox checkBox = (CheckBox) getView().findViewById(R.id.checkBox);
            EditText repsEditText = (EditText) getView().findViewById(R.id.repsEditText);
            EditText weightEditText = (EditText) getView().findViewById(R.id.weightEditText);

            if (checkBox.isChecked()) {
                String compiledString = repsEditText.getText() + "@" + weightEditText.getText();
                WorkoutAssistorAssemblerClass.getInstance().setRepsWeight(parentExercise, compiledString);
            }
        }
    }

    public String getCheckedStatus(){
        boolean isChecked;

        CheckBox checkBox = (CheckBox) view.findViewById(R.id.checkBox);
        isChecked = checkBox.isChecked();

        String toString = String.valueOf(isChecked);

        return toString;
    }

    public String getParentExercise(){
        return parentExercise;
    }

}
set as active should check to see if template has no days
set as active template was checked despite us not having no templates
<RelativeLayout
            xmlns:android="http://schemas.android.com/apk/res/android"
            xmlns:tools="http://schemas.android.com/tools"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:paddingLeft="@dimen/activity_horizontal_margin"
            android:paddingRight="@dimen/activity_horizontal_margin"
            android:paddingTop="@dimen/activity_vertical_margin"
            android:paddingBottom="@dimen/activity_vertical_margin"
            tools:context="com.template_system_default.TemplateSaved"
            android:gravity="center"
            android:id="@+id/templateSavedHolder"
            android:visibility="visible"
    > // old ass template saved lookin ass
private static final String FIREBASE_URL = "https://liftdom-27d9d.firebaseio.com/"; // in
templatesaved
* So first let's get the first case down pat. Then second, then third, then try it
*    eventually with first time tutorial. Also need to get first time tut squared away
*    everywhere.
*
*
* First case: No edit, no public.
*  - we load in the default state and update. then update from there.
*  - if we navigate away and come back it's just the same, is edit and template name edit
*      stay false/null.
*  - it needs to be in the exact state as it would be if we saved it there.
*  - isEdit will be false, but runningAssistor will be "true"
*  - two sub cases here: coming in fresh, and coming in with something in the
*      templatesRunning node.
*
*  Second case: Is edit, not from public.
*      - First we load in all the stuff like it's from edit. then we need to update the
*      state and REMEMBER that it's edit, what the name is, etc.
*      - Each time it comes in FROM saved templates it should run over the current
*      templateRunning node and start fresh.
*  Third case: is edit, from public
*
*      - same as with second case, we just need to remember that it's edit, and all the
*      information that it gets and holds within its state.
*
*
*
/**
 * Where we at: made cleanUp method. So now we need to clean up state, then get
 * the templateModelClass and inflate from that (remember we have a method for
 * that now). Then we need to work on getting the save state exactly like it
 * would be for full template saving, remembering to save day sets that don't
 * have selected days. Maybe force selections? idk.
 */
cleanUpState();
/**
 * Let's collect everything that happens
 * now we need to be able to save empty day sets/ex sets
 *
 * The first day set is being saved correctly, - 1, bp flat.
 *
 * But then on saving the second, it re-saves the first as a new day set and then saves
 * the second one third.
 *
 *
 * OK so it shouldn't be sending bp flat over at all, or if it does it should detect that
 * it is 1.
 *
 *
 *
 */
/**
 * Ok, so we eliminated the pop up window and it inflates correctly.
 * We need to know why.
 *
 * Also we're using checkRunningNode instead of the direct inflate
 * running. (actually that doesn't matter, they both work.)
 * So somewhere along that line shit gets fucked.
 * Another problem is when the save dialog comes up (so onPause then
 * maybe onResume), we lose the days selected from DoW frag. And bc
 * we then update? so it updates the day less version.
 *
 * So I think it first goes to onPause, then the day is unselected,
 * then onResume hits and inflates. But no, somewhere in there it
 * updates.
 *
 * Ok it updates right after inflate? So we need to put breakpoints
 * in onResume, inflate beginning, inflate before update, inflate at
 * update, then update.
 *
 * Also it looks like the template name isn't being saved to the
 * running ref.
 *
 * OK, by the time it gets to updating, the doW1.map is actually
 * correct with Monday selected. But the TemplateEditorSingleton
 * mapOne has it as 1/no day selected. And visually we don't see
 * Monday selected.
 */
//String string =
//        dataSnapshot.getValue(String.class);
//if(string != null){
//    Intent intent = new Intent(TemplateEditorActivity.this,
//            UseRunningTemplateDialog.class);
//    startActivityForResult(intent, 3);
//}
//DatabaseReference firstTimeRef = mRootRef.child("firstTime").child(uid).child
//        ("isFromScratchFirstTime");
//if (getIntent().getExtras().getString("isEdit") != null) {
//    if (getIntent().getExtras().getString("isEdit").equals("no")) {
//    }
//}
/**
 * First we check if there's a runningTemplate.
 * It's probably safest if we clear everything and run this whole thing every time.
 * We could just have it twice. And in onStart we show the dialog and in onResume
 * we don't. We also need a way of reading day sets without any days selected.
 * So we should clear lists every time and rebuild.
 */
/**
* Ok, where we at:
* We need to handle isEdit. When it first comes in, it knows it's isEdit
* from the getIntent extra. Throughout the shit including savedTemplate it
* is using that. So we need to set within the templateModelClass for running
* that it isEdit and then when we detect that it is from the running model,
* we need to see if we can set the intent extra as isEdit so it can detect
* that when it's saving and processing in the end. Basically restore the
* vanilla isEdit experience but from running. Then we also were thinking
* that anytime you come from the savedTemplates page (clicking edit button)
* it overrules whatever's in the running node. so this would only be used if
* you do that once, leave, then come back via the from scratch button.
* Also we need to remove the template name view if it isn't edit. tho idk if
* that will be a problem.
*/
//@Override
    //public String getFormattedValue(float value, AxisBase axis) {
    //    // from float to long
    //    long convertedTimestamp = ((long) value);
//
    //    // Retrieve original timestamp
    //    long originalTimestamp = referenceTimestamp + convertedTimestamp;
//
    //    return getDate(originalTimestamp);
    //}

uid3 = FirebaseAuth.getInstance().getCurrentUser().getUid();
userRef1 = FirebaseDatabase.getInstance().getReference().child("user").child(uid3);
userRefListener = userRef1.addValueEventListener(new ValueEventListener() {
private ValueEventListener userRefListener;
String uid3;
DatabaseReference userRef1;

{
  "rules": {
    "user": {
      "$uid": {
        ".read": "$uid === auth.uid",
        ".write": "$uid === auth.uid"
      }
    },
    "chatGroups": {
      "$uid": {
        ".read": "$uid === auth.uid",
        ".write": "$uid === auth.uid"
      }
    },
    "completedExercises": {
      "$uid": {
        ".read": "$uid === auth.uid",
        ".write": "$uid === auth.uid"
      }
    },
    "customExercises": {
      "$uid": {
        ".read": "$uid === auth.uid",
        ".write": "$uid === auth.uid"
      }
    },
    "chats": {
        ".read": "auth != null",
        ".write": "auth != null"
    },
    "defaultTemplates": {
      ".read": "auth != null",
    },
    "feed": {
        ".read": "auth != null",
        ".write": "auth != null"
    },
    "feedbackChat": {
        ".read": "auth != null",
        ".write": "auth != null"
    },
    "feedbackChatMaster": {
        ".read": "auth != null",
        ".write": "auth != null"
    },
    "firstTime": {
      "$uid": {
        ".read": "$uid === auth.uid",
        ".write": "$uid === auth.uid"
      }
    },
    "followers": {
        ".read": "auth != null",
        ".write": "auth != null"
    },
    "following": {
        ".read": "auth != null",
        ".write": "auth != null"
    },
    "globalFeed": {
        ".read": "auth != null",
        ".write": "auth != null"
    },
    "loginDate": {
      "$uid": {
        ".read": "$uid === auth.uid",
        ".write": "$uid === auth.uid"
      }
    },
    "mainFeedBanner": {
      "$uid": {
        ".read": "$uid === auth.uid",
        ".write": "$uid === auth.uid"
      }
    },
    "maxes": {
      "$uid": {
        ".read": "$uid === auth.uid",
        ".write": "$uid === auth.uid"
      }
    },
    "notifications": {
      ".read": "auth != null",
      ".write": "auth != null"
    },
    "publicTemplates": {
      ".read": "auth != null",
      ".write": "auth != null"
    },
    "runningAssistor": {
      "$uid": {
        ".read": "$uid === auth.uid",
        ".write": "$uid === auth.uid"
      }
    },
    "selfFeed": {
        ".read": "auth != null",
        ".write": "auth != null"
    },
    "templates": {
      "$uid": {
        ".read": "$uid === auth.uid",
        ".write": "$uid === auth.uid"
      }
    },
    "templatesInbox": {
        ".read": "auth != null",
        ".write": "auth != null"
    },
    "userList": {
      "$uid": {
        ".read": "$uid === auth.uid",
        ".write": "$uid === auth.uid"
      }
    },
    "userNames": {
        ".read": "auth != null",
        ".write": "auth != null"
    },
    "versionCheck": {
      "$uid": {
        ".read": "$uid === auth.uid",
        ".write": "$uid === auth.uid"
      }
    },
    "workoutHistory": {
      "$uid": {
        ".read": "$uid === auth.uid",
        ".write": "$uid === auth.uid"
      }
    }
  }
}

    - Now, how do we do that?
        - Disconnect UI from being updated automatically from FB.
            - problem now is it doesn't get updates from service
        - Need a check if exInfoHashMap is null, if it is, remake the original.


    - best option might be to just work on detaching ui from live updates
        then somehow use the firebase offline to enable offline. or manually use Paper.
        will need to have template ref for offline as well as running assistor
    - this was still assuming that we have connection for the initial read of
        the workout history/template/running assistor. Once we have the relevant data
        we simply detach the modifications from updating, and the listener from updating things.

    - first we need our templates saved to disk
    - then we need to do the whole checking process of WA/AH in disk
    - which means we need to have RunningAssistor in disk
    - Maybe can help stop some of the finnicky ness of the WA and it's relation to states
WA/main service/template creation and saving/ whole process needs to be self contained offline
    - going to have to use Room or equivalent. Massive undertaking.

//if(getExInfoHashMap().get(tokens[0] + key).size() > (Integer.parseInt(tokens[1]) + 1)){
                        //    // if room to increase ([1])
                        //    //Log.i("progressModel", "107, cursor = " + cursor);
                        //    int addedKey = Integer.parseInt(tokens[1]) + 1;
                        //    if(getExInfoHashMap().get(tokens[0] + key).get(String.valueOf(addedKey) + key).size() > Integer
                        //            .parseInt(tokens[2])){
                        //        // if room to increase ([2]) of next list
                        //        //int newValue = Integer.parseInt(tokens[1]) + 1;
                        //        //Log.i("progressModel", "111, cursor = " + cursor);
                        //        setViewCursor(tokens[0] + "_" + String.valueOf(addedKey) + "_" + tokens[2]);
                        //    }else{
                        //        //Log.i("progressModel", "116, cursor = " + cursor);
                        //        // keep increasing in original?
                        //        if(getExInfoHashMap().get(tokens[0] + key).get(tokens[1] + key).size() > (Integer.parseInt
                        //                (tokens[2]) + 1)){
                        //            // increase
                        //            //Log.i("progressModel", "121, cursor = " + cursor);
                        //            int newValue = Integer.parseInt(tokens[2]) + 1;
                        //            setViewCursor(tokens[0] + "_" + tokens[1] + "_" + String.valueOf(newValue));
                        //        }else{
                        //            // move forward
                        //            int newValue = Integer.parseInt(tokens[0]) + 1;
                        //            if(getExInfoHashMap().size() >= newValue){
                        //                // next map
                        //                setViewCursor(String.valueOf(newValue) + "_0_1");
                        //                //Log.i("progressModel", "126, cursor = " + cursor);
                        //                //Log.i("progressModel", "move forward (superset - else end 1)");
                        //            }else{
                        //                // done with workout
                        //                //setViewCursor("workoutDone");
                        //            }
                        //        }
                        //    }
                        //}else{
                        //    // if need to loop back
                        //    int newValue = Integer.parseInt(tokens[2]) + 1;
//
                        //    if(getExInfoHashMap().get(tokens[0] + key).get("0_key").size() > newValue){
                        //        // increase
                        //        //Log.i("progressModel", "138, cursor = " + cursor);
                        //        setViewCursor(tokens[0] + "_0_" + String.valueOf(newValue));
                        //    }else{
                        //        // move forward
                        //        //Log.i("progressModel", "142, cursor = " + cursor);
                        //        //Log.i("progressModel", "move forward (superset - else end 2)");
                        //    }
                        //}

DatabaseReference feedRef = mRootRef.child("feed").child(xUid);
        Query feedQuery = feedRef.limitToLast(10);
        feedQuery.addListenerForSingleValueEvent(new ValueEventListener() {
            @Override
            public void onDataChange(DataSnapshot dataSnapshot) {
                if(!dataSnapshot.exists()){
                    loadingView.setVisibility(View.GONE);
                    noResultsView.setVisibility(View.VISIBLE);
                } else {
                    int inc = 0;
                    ArrayList<CompletedWorkoutPostFrag> postFragArrayList = new ArrayList<CompletedWorkoutPostFrag>();
                    for (DataSnapshot dataSnapshot1 : dataSnapshot.getChildren()) {

                        //CompletedWorkoutClass completedWorkoutClass = (CompletedWorkoutClass) dataSnapshot1.getValue();
                        // Could have a variable here with however many things to load, and then increase it on pull
                        // to refresh?
                        Map<String, Object> map = (Map<String, Object>) dataSnapshot1.getValue();

                        FragmentManager fragmentManager = getActivity().getSupportFragmentManager();
                        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();

                        CompletedWorkoutPostFrag completedWorkoutPostFrag = new CompletedWorkoutPostFrag();
                        completedWorkoutPostFrag.userId = (String) map.get("userId");
                        completedWorkoutPostFrag.userName = (String) map.get("userName");
                        completedWorkoutPostFrag.publicComment = (String) map.get("publicComment");
                        completedWorkoutPostFrag.workoutInfoList = (List) map.get("workoutInfoList");
                        completedWorkoutPostFrag.dateAndTime = (String) map.get("dateTime");
                        completedWorkoutPostFrag.repsMap = (HashMap<String, Boolean>) map.get("repsMap");

                        postFragArrayList.add(completedWorkoutPostFrag);

                        //fragmentTransaction.add(R.id.postsHolder, completedWorkoutPostFrag);
                        //fragmentTransaction.commit();

                        inc++;
                        if(inc == dataSnapshot.getChildrenCount()){

                            loadingView.setVisibility(View.GONE);

                            Collections.reverse(postFragArrayList);

                            for(CompletedWorkoutPostFrag completedWorkoutPost : postFragArrayList){
                                fragmentTransaction.add(R.id.postsHolder, completedWorkoutPost);
                            }

                            fragmentTransaction.commit();
                        }
                    }
                }
            }

            @Override
            public void onCancelled(DatabaseError databaseError) {

            }
        });





         // first, the OTHER person gains YOU as a follower
                        final DatabaseReference otherFollowerRef = mRootRef.child("followers").child(xUid);
                        otherFollowerRef.addListenerForSingleValueEvent(new ValueEventListener() {
                            @Override
                            public void onDataChange(DataSnapshot dataSnapshot) {
                                if(dataSnapshot.exists()){
                                    SharedPreferences sharedPref = getActivity().getSharedPreferences("prefs", Activity.MODE_PRIVATE);
                                    FollowersModelClass followersModelClass = dataSnapshot.getValue(FollowersModelClass.class);
                                    followersModelClass.addFollowerToMap(uid, sharedPref.getString("userName", "loading..."));
                                    otherFollowerRef.setValue(followersModelClass).addOnCompleteListener(new OnCompleteListener<Void>() {
                                        @Override
                                        public void onComplete(@NonNull Task<Void> task) {
                                            // second, YOU gain the OTHER person as "following"
                                            final DatabaseReference myFollowingList = mRootRef.child("following").child(uid);
                                            myFollowingList.addListenerForSingleValueEvent(new ValueEventListener() {
                                                @Override
                                                public void onDataChange(DataSnapshot dataSnapshot) {
                                                    if(dataSnapshot.exists()){
                                                        FollowingModelClass followingModelClass = dataSnapshot.getValue(FollowingModelClass.class);
                                                        followingModelClass.addFollowingToMap(xUid, userName);
                                                        myFollowingList.setValue(followingModelClass).addOnCompleteListener(new OnCompleteListener<Void>() {
                                                            @Override
                                                            public void onComplete(@NonNull Task<Void> task) {
                                                                followUserButton.setVisibility(View.GONE);
                                                                unfollowUserButton.setVisibility(View.VISIBLE);
                                                            }
                                                        });
                                                    }else{
                                                        FollowingModelClass followingModelClass = new FollowingModelClass(xUid, userName);
                                                        myFollowingList.setValue(followingModelClass).addOnCompleteListener(new OnCompleteListener<Void>() {
                                                            @Override
                                                            public void onComplete(@NonNull Task<Void> task) {
                                                                followUserButton.setVisibility(View.GONE);
                                                                unfollowUserButton.setVisibility(View.VISIBLE);
                                                            }
                                                        });
                                                    }
                                                }

                                                @Override
                                                public void onCancelled(DatabaseError databaseError) {

                                                }
                                            });
                                        }
                                    });
                                }else{
                                    SharedPreferences sharedPref = getActivity().getSharedPreferences("prefs", Activity.MODE_PRIVATE);
                                    FollowersModelClass followersModelClass = new FollowersModelClass(uid, sharedPref.getString("userName", "loading..."));
                                    otherFollowerRef.setValue(followersModelClass).addOnCompleteListener(new OnCompleteListener<Void>() {
                                        @Override
                                        public void onComplete(@NonNull Task<Void> task) {
                                            // second, YOU gain the OTHER person as "following"
                                            final DatabaseReference myFollowingList = mRootRef.child("following").child(uid);
                                            myFollowingList.addListenerForSingleValueEvent(new ValueEventListener() {
                                                @Override
                                                public void onDataChange(DataSnapshot dataSnapshot) {
                                                    if(dataSnapshot.exists()){
                                                        FollowingModelClass followingModelClass = dataSnapshot.getValue(FollowingModelClass.class);
                                                        followingModelClass.addFollowingToMap(xUid, userName);
                                                        myFollowingList.setValue(followingModelClass).addOnCompleteListener(new OnCompleteListener<Void>() {
                                                            @Override
                                                            public void onComplete(@NonNull Task<Void> task) {
                                                                followUserButton.setVisibility(View.GONE);
                                                                unfollowUserButton.setVisibility(View.VISIBLE);
                                                            }
                                                        });
                                                    }else{
                                                        FollowingModelClass followingModelClass = new FollowingModelClass(xUid, userName);
                                                        myFollowingList.setValue(followingModelClass).addOnCompleteListener(new OnCompleteListener<Void>() {
                                                            @Override
                                                            public void onComplete(@NonNull Task<Void> task) {
                                                                followUserButton.setVisibility(View.GONE);
                                                                unfollowUserButton.setVisibility(View.VISIBLE);
                                                            }
                                                        });
                                                    }
                                                }

                                                @Override
                                                public void onCancelled(DatabaseError databaseError) {

                                                }
                                            });
                                        }
                                    });
                                }
                            }

                            @Override
                            public void onCancelled(DatabaseError databaseError) {

                            }
                        });

                        followingUsersRef.child(xUid).child(uid).setValue(null).addOnCompleteListener(new OnCompleteListener<Void>() {
                                            @Override
                                            public void onComplete(@NonNull Task<Void> task) {
                                                followerUsersRef.child(uid).child(xUid).setValue(null).addOnCompleteListener(new OnCompleteListener<Void>() {
                                                    @Override
                                                    public void onComplete(@NonNull Task<Void> task) {
                                                        unfollowUserButton.setVisibility(View.GONE);
                                                        followUserButton.setVisibility(View.VISIBLE);
                                                    }
                                                });
                                            }
                                        });

// removes all the incompatible workouts in global feed based on date
        //final DatabaseReference globalRef = FirebaseDatabase.getInstance().getReference().child("globalFeed");
        //globalRef.addListenerForSingleValueEvent(new ValueEventListener() {
        //    @Override
        //    public void onDataChange(DataSnapshot dataSnapshot) {
        //        for (DataSnapshot dataSnapshot1 : dataSnapshot.getChildren()) {
        //            DateTime dateTime1 = DateTime.parse("2017-12-02");
        //            CompletedWorkoutModelClass workoutModelClass = dataSnapshot1.getValue(CompletedWorkoutModelClass
        //                    .class);
        //            DateTime dateTime2 = DateTime.parse(workoutModelClass.getDateTime());
        //            if(dateTime2.isBefore(dateTime1)){
        //                globalRef.child(workoutModelClass.getRef()).setValue(null);
        //            }
        //        }
        //    }
//
        //    @Override
        //    public void onCancelled(DatabaseError databaseError) {
//
        //    }
        //});

        // current issue is that mExInfoHasMap is being set to null after saving a revised workout.
        //DatabaseReference myRef = FirebaseDatabase.getInstance().getReference().child("runningAssistor")
        //        .child(uid).child("assistorModel").child("exInfoHashMap");
        //HashMap<String, HashMap<String, List<String>>> mExInfoHashMap = new HashMap<>();
        //List<String> list1 = new ArrayList<>();
        //List<String> list2 = new ArrayList<>();
        //list1.add("Deadlift (Barbell - Conventional)");
        //list1.add("4@25_checked");
        //list1.add("4@25_checked");
        //list1.add("4@25_unchecked");
        //list2.add("Bench Press (Barbell - Flat)");
        //list2.add("3@58_checked_ss");
        //list2.add("3@58_checked_ss");
        //list2.add("3@58_unchecked_ss");
        //list2.add("3@58_unchecked_ss");
        //HashMap<String, List<String>> map = new HashMap<>();
        //map.put("0_key", list1);
        //map.put("1_key", list2);
        //mExInfoHashMap.put("1_key", map);
        //myRef.setValue(mExInfoHashMap);

        // updates <1.29 posts to the global feed
        //DatabaseReference selfFeedRef = FirebaseDatabase.getInstance().getReference().child("selfFeed");
        //selfFeedRef.addListenerForSingleValueEvent(new ValueEventListener() {
        //    @Override
        //    public void onDataChange(DataSnapshot dataSnapshot) {
        //        Map fanoutObject = new HashMap<>();
        //        int index1 = 0;
        //        int index2 = 0;
        //        for(DataSnapshot dataSnapshot1 : dataSnapshot.getChildren()){
        //            index1++;
        //            index2 = 0;
        //            for(DataSnapshot dataSnapshot2 : dataSnapshot1.getChildren()){
        //                index2++;
        //                fanoutObject.put("/globalFeed/" + dataSnapshot2.getKey(), dataSnapshot2.getValue());
        //                if(index1 == dataSnapshot.getChildrenCount()){
        //                    if(index2 == dataSnapshot1.getChildrenCount()){
        //                        DatabaseReference rootRef = FirebaseDatabase.getInstance().getReference();
        //                        rootRef.updateChildren(fanoutObject);
        //                    }
        //                }
        //            }
        //        }
        //    }
//
        //    @Override
        //    public void onCancelled(DatabaseError databaseError) {
//
        //    }
        //});

        //DatabaseReference burkRef = FirebaseDatabase.getInstance().getReference().child("templates").child
        //        ("EcCB9ayXcegCctEaT1Y7n98NC5G2").child("MindPrimary");
        //burkRef.addListenerForSingleValueEvent(new ValueEventListener() {
        //    @Override
        //    public void onDataChange(DataSnapshot dataSnapshot) {
        //        TemplateModelClass templateModelClass = dataSnapshot.getValue(TemplateModelClass.class);
        //        templateModelClass.setUserName2("Brodin");
        //        templateModelClass.setUserId2(uid);
        //        DatabaseReference myRef = FirebaseDatabase.getInstance().getReference().child("templatesInbox").child
        //                (uid).child("MindPrimary");
        //        myRef.setValue(templateModelClass);
        //    }
//
        //    @Override
        //    public void onCancelled(DatabaseError databaseError) {
//
        //    }
        //});

        //firebaseAdapter = new FirebaseRecyclerAdapter<CompletedWorkoutModelClass, CompletedWorkoutViewHolder>
        //        (CompletedWorkoutModelClass.class, R.layout.completed_workout_list_item2,
        //                CompletedWorkoutViewHolder.class, databaseReference) {
        //    @Override
        //    protected void populateViewHolder(CompletedWorkoutViewHolder viewHolder,
        //                                      CompletedWorkoutModelClass model, int position) {
        //        //if(model.getUserId().equals(uid)){
        //        //viewHolder.setPosition(position);
//
        //        /**
        //         * Going to try the new FirebaseUI version. Or at least see if we're on the old version.
        //         */
//
        //        viewHolder.setCurrentUserId(uid);
        //        viewHolder.setImperialPOV(isImperial);
        //        viewHolder.setActivity(getActivity());
        //        viewHolder.setRefKey(model.getRef());
        //        viewHolder.setUserId(model.getUserId());
        //        viewHolder.setPostInfo(model.getWorkoutInfoMap(), getActivity(), getContext(),
        //                model.isIsImperial());
        //        viewHolder.setUpProfilePics(model.getUserId());
        //        viewHolder.setCommentRecycler(model.getRef());
        //        viewHolder.setUserName(model.getUserName());
        //        viewHolder.setUserLevel(model.getUserId(), rootRef);
        //        viewHolder.setPublicDescription(model.getPublicDescription());
        //        viewHolder.setTimeStamp(model.getDateTime());
        //        //viewHolder.setReppedCount(model.getRepCount());
        //        viewHolder.setHasReppedList(model.getHasReppedList());
        //        //viewHolder.setRepsCounterView(model.getRepCount());
        //        //viewHolder.setIsRepped(model.isHasRepped(), false);
        //        //viewHolder.setActivity(getActivity());
        //        //if(model.getBonusList() != null){
        //        try{
        //            viewHolder.mBonusView.setText(model.getBonusList().get(0));
        //        }catch (NullPointerException e){
//
        //        }
//
        //        //viewHolder.setBonusView(model.getBonusList());
        //        //}
        //        //}else{
        //        //    viewHolder.hideLayout();
        //        //}
//
//
        //    }
        //};


/**
* So what're the cases where this would
* fuck up?
* 1. If sets/reps are not set to increase.
* 2. If sets - wSL < 1 || reps - wSL < 1
*
* idk
*
* Let's write out some cases.
*
* ---------------------------------------
* 1 x 2 @ 30 (OG set scheme)
* ---------------------------------------
* s = 1_1 (every 1 weeks, increase s by 1)
* r = 2_1 (every 2 weeks, increase r by 1)
* w = 3_1 (every 3 weeks, increase w by 1)
* ----------------------------------------
*
* wSL = 1
* 2 x 2 @ 30
*
* wSL = 2
* 3 x 3 @ 30
*
* wSL = 3
* 4 x 3 @ 31
*
* wSL = 4 (now it's above w so we loop
* (wSL - 1) times)
* (loop 1){
*      s = 4 - 1 // s == 3
*      r = 3 - 1 // r == 2
* }
* (loop 2){
*      s = 3 - 1 // s == 2
* }
* (loop 3){
*      s = 2 - 1 // s == 1
* }
* 1 x 2 @ 31 | what we actually got: 2 x 2 @ 31
*
* this is bc we're increasing s/r
* before checking for the loop
*
* we're going to have to apply the %
* method to the weight thing
*/

/**
     ArrayList<String> templateListWithNum = new ArrayList<>();
     ArrayList<String> templateNamesListSansNum = new ArrayList<>();

     File myDir = getContext().getFilesDir();
     File[] templateFiles = myDir.listFiles();

     int length = templateFiles.length;


     for(int i = 0; i < length; i++){
     templateListWithNum.add(templateFiles[i].getName());
     }

     for(String withNum : templateListWithNum){
     String sansNum = lastCharRemover(withNum);
     if(!templateNamesListSansNum.contains(sansNum) && !sansNum.equals("instant-ru") && !s3Check(sansNum)){
     templateNamesListSansNum.add(sansNum);
     }

     }

     for(String template : templateNamesListSansNum){

     TemplateListItemFrag templateListItem = new TemplateListItemFrag();

     templateListItem.templateName = template;

     FragmentManager fragmentManager1 = getActivity().getSupportFragmentManager();
     androidx.fragment.app.FragmentTransaction fragmentTransaction1 = fragmentManager1.beginTransaction();
     fragmentTransaction1.add(R.id.myTemplatesList, templateListItem);
     fragmentTransaction1.addToBackStack(null);
     fragmentTransaction1.commit();

     }**/


    /**
     mTemplateRef.addValueEventListener(new ValueEventListener() {
    @Override
    public void onDataChange(DataSnapshot dataSnapshot) {
    String text = dataSnapshot.getValue(String.class);
    // text view var mConditionTextView.setText(text);
    }

    @Override
    public void onCancelled(DatabaseError databaseError) {

    }
    });

     view.setOnClickListener(new View.OnClickListener() {
     public void onClick(View v) {
     mConditionRef.setValue("Sunny");
     }
     });

     view.setOnClickListener(new View.OnClickListener() {
     public void onClick(View v) {
     mConditionRef.setValue("Foggy");
     }
     });
     **/


}